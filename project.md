# AI Deployment Platform - Project Plan

## Executive Summary
The goal is to build a "Full Stack AI Deployment Platform" that democratizes software deployment. It allows non-technical users (students, accountants, professors) to take code generated by AI (ChatGPT, Claude, etc.)—whether it's a React frontend, Python script, or Java backend—and instantly deploy it to a live, public URL without touching a terminal or understanding servers.

**Core Value Proposition:** "Drop code, get a link."

## User Journey
1.  **Input:** User visits the platform and either:
    *   Pastes code directly into an editor.
    *   Uploads a zip file of code.
    *   (Future) Prompts an integrated AI to "Build a mortgage calculator" which generates and auto-deploys the code.
2.  **Processing:** The platform analyzes the files, detects the language/framework (e.g., `package.json` -> Node/React, `requirements.txt` -> Python), and builds a secure container.
3.  **Deployment:** The container is spun up in a sandboxed environment.
4.  **Output:** The user receives a unique URL (e.g., `https://mortgage-calc-123.ai-deploy.com`) to share or use.

## Features

### MVP (Minimum Viable Product)
-   **Multi-Language Support:** Auto-detection for:
    -   **Frontend:** React, HTML/CSS/JS, Vue.
    -   **Backend:** Python (Flask/Django/FastAPI), Node.js (Express), Java (Spring Boot).
-   **Simple Dashboard:**
    -   Project list.
    -   "New Project" wizard (Upload/Paste).
    -   Logs viewer (to see build/runtime errors).
-   **Auto-HTTPS:** Free SSL for all generated domains.
-   **Basic Auth:** Optional password protection for user deployments.

### Future Scope
-   **Integrated AI Coding Assistant:** A built-in chat interface to generate the code within the platform itself.
-   **Database Provisioning:** One-click PostgreSQL/Redis instances attached to projects.
-   **Custom Domains:** Allow users to connect `www.my-site.com`.
-   **Monetization:** Free tier (sleeping apps) vs. Pro tier (always on, more resources).

## Technical Architecture

### High-Level Diagram
```mermaid
graph TD
    User[User] -->|Visits Dashboard| Proxy[Traefik Reverse Proxy]
    Proxy -->|Main Domain| Django[Django Web App]
    Proxy -->|Subdomains (*.app)| UserContainer[User App Container]
    
    Django -->|Spawns Thread/Process| Docker[Docker Engine]
    Docker -->|Spawns| UserContainer
    
    Django -->|Reads/Writes| SQLite[(SQLite DB)]
    Django -->|Stores Files| FS[Local Filesystem (artifacts/)]
```

### Tech Stack

#### The Monolith (Full Stack)
-   **Framework:** **Django 5.x** (Python). Handles both the UI (Templates) and the Logic.
-   **Frontend:** Django Templates + **HTMX** (for dynamic interactions without writing React) + Tailwind CSS.
-   **Database:** **SQLite**. Simple, file-based database for storing project metadata and user info.
-   **File Storage:** Local filesystem. Uploaded files and build artifacts will be stored in `artifacts/${project_id}/`.
-   **Task Queue:** Python `threading` or `concurrent.futures` for background tasks.

#### Infrastructure & Virtualization
-   **Virtualization Engine:** **Docker Engine**.
-   **Control Interface:** **Docker SDK for Python**. The Django app will talk directly to the Docker daemon to build images and run containers.
-   **Routing:** **Traefik**. A modern reverse proxy that will sit in front of everything. It will route `anydeploy.com` to Django and `*.anydeploy.com` to the specific Docker containers running user apps.

## Roadmap

### Phase 1: Foundation
-   [ ] Initialize Django project.
-   [ ] Set up Docker-in-Docker (DinD) or socket mounting for local dev.
-   [ ] Create the "Project" data model.

### Phase 2: The Build Engine
-   [ ] Implement background task (threading/DB-queue) to take a Git URL or Zip file.
-   [ ] Use `docker-py` to build a Docker image from the user's code (auto-generating Dockerfiles if needed).

### Phase 3: The Runtime
-   [ ] Implement logic to spin up a container from the built image.
-   [ ] Configure Traefik labels dynamically to route traffic to the new container.

### Phase 4: Security & Polish
-   [ ] Add resource limits (CPU/RAM) to user containers.
-   [ ] Ensure user containers are on an isolated Docker network.

## Security Considerations (Critical)
1.  **Abuse Prevention:** Users might try to mine crypto or launch DDoS attacks.
    *   *Mitigation:* Strict CPU/Network limits. Block outbound traffic to port 25 (SMTP) and others.
2.  **Isolation:** Standard Docker is not enough.
    *   *Mitigation:* Use gVisor to intercept syscalls.
3.  **Ephemeral Filesystem:**
    *   *Mitigation:* User apps should have read-only filesystems or ephemeral storage that wipes on restart.
